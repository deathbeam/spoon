# vim: set ft=coffee:

from Foo import Bar as Chocolate # Python-like imports and module system

# Interfaces with default implementation
interface Printer
  function print(message)
    trace message # Optional parenthesis

class Hello
  function hello
    return "Hello"

class World extends Hello
  function world
    return "World"

class Messenger extends World
  implements Printer

  function this.run
    self = Messenger.new! # Ruby-like method of creating new objects
    print "#{self.hello!} #{self.world!}" # Ruby-like string interpolation

# Generic types and static typing
class MyValue[T]
  value as T

  function new(value as T)
    this.value = value

trace MyValue[String].new("HI!")
trace MyValue[Int].new(5)
Messenger.run! # Exclamation mark used for 0-arg argument calls

###
Expected compiled result:

import Foo.Bar as Chocolate;

@:mixin interface Printer {
  public function print(message) {
    trace(message);
  }
}

class Hello {
  public function hello() {
    return "Hello";
  }
}

class World extends Hello {
  public function world() {
    return "World";
  }
}

class Messenger extends World implements Printer {
  public static function run() {
    var self = new Messenger();
    print('${self.hello()} ${self.world()}');
  }
}

class MyValue<T> {
  public var value : T;

  public function new(value : T) {
    this.value = value;
  }
}

class Test {
  @:keep public static function main() {
    if (Reflect.hasField(Foo, "main")) {
      Reflect.callMethod(Foo, Reflect.field(Foo, "main"), []);
    }

    trace(new MyValue<String>("HI!"));
    trace(new MyValue<Int>(5));
    Messenger.run();
  }
}
###
