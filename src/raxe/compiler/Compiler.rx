import raxe.tools.StringHandle
#if !js
  import sys.io.File
#end

###############################################################################
# The most important Raxe class, which compiles Raxe source to Haxe source
###############################################################################
class @
  private def fileName : String = ""
  private def currentName : String = ""
  private def currentType : String = ""
  private def currentExpression : String = ""
  private def hasVisibility : Bool = false
  private def opened : Int = -1
  private def currentOpened : Int = -1
  private def script : Bool = false

  #############################################################################
  # Array of tokens used for StringHandle to correctly parse Raxe files
  #############################################################################
  def tokens = [
    # Line break
    "\n", ";",

    # Whitespace skip
    "\#", "@new", "@@", "@", "\"", "'", "$", "/",

    # Types
    "::", "class", "enum", "abstract", "trait", "interface",

    # Modifiers
    "public", "private",

    # Special keywords
    "import", "def", "new", "end", "do", "typedef", "try", "catch", "void",

    # Brackets
    "{", "}", "(", ")", "[", "]",

    # Word operators
    "isnt", "is", "and", "or", "not",

    # Operators (< is also used for inheritance)
    ":", "?", "=", "+", "-", "*", ".", "/", "," , "|", "&",  "^", "%", "<", ">", "~",

    # Expressions
    "elsif", "if", "else", "while", "for", "switch", "when",
  ]

  #############################################################################
  # Create new instance of Raxe compiler
  # @param script Specify if it is RaxeScript or Raxe compiler (default false)
  #############################################################################
  def new(script : Bool = false)
    @script = script
  end

  #if !js
    #############################################################################
    # Compile Raxe file and returns Haxe result
    # @param directory root project directory, needed for correct package names
    # @param file file path to compile
    # @return Raxe file compiled to it's Haxe equivalent
    #############################################################################
    def compileFile(directory : String, file : String) : String
      def currentPackage = file
        .replace(directory, "")
        .replace("\\", "/")

      fileName = currentPackage
        .substr(currentPackage.lastIndexOf("/") + 1)
        .replace(".rx", "")

      currentName = fileName

      currentPackage = currentPackage
        .replace(currentPackage.substr(currentPackage.lastIndexOf("/")), "")
        .replace("/", ".")

      if(currentPackage.charAt(0) == ".")
        currentPackage = currentPackage.substr(1)
      end

      run(new StringHandle(File.getContent(file), tokens)
        .insert("package " + currentPackage + ";using Lambda;using StringTools;")
        .increment()
      ).content
    end
  #end

  #############################################################################
  # Compile Raxe code and returns Haxe result
  # @param code Raxe source code
  # @return Raxe code compiled to it's Haxe equivalent
  #############################################################################
  def compileString(code : String)
    run(new StringHandle(code,tokens)).content
  end

  #############################################################################
  # Process content of StringHandle and return it modified
  # @param script Determine if automatically insert package and class names
  # @param handle Handle with initial content and position
  # @return modified string handle with adjusted position and content
  #############################################################################
  def run(handle : StringHandle) : StringHandle
    while(handle.nextToken())
      process(handle)
    end

    return handle
  end

  #############################################################################
  # Process single token of StringHandle and return it modified
  # @param script Determine if automatically insert package and class names
  # @param handle Handle with initial content and position
  # @return modified string handle with adjusted position and content
  #############################################################################
  private def process(handle : StringHandle) : StringHandle
    # Skip compiler defines and annotations
    if(handle.match("$") && handle.at("$["))
      handle.remove()
      handle.insert("@")
      handle.increment()
      consumeBrackets(handle, "[", "]", "", "")
      safeNextToken(handle)

      if(handle.match("\n"))
        handle.increment()
      end
    elsif(handle.match("@@"))
      if(handle.safeMatch("@@"))
        handle.remove()
        handle.insert(currentName)
      else
        handle.remove()
        handle.insert(currentName + ".")
      end

      handle.increment()
    elsif(handle.match("~") && handle.at("~/"))
      handle.increment("~/")

      while(handle.nextToken())
        if(handle.match("/") && isNotEscaped(handle))
          handle.increment()
          break
        end

        handle.increment()
      end
    elsif(handle.match("@"))
      if(handle.safeMatch("@"))
        handle.remove()
        handle.insert("this")
        handle.increment()
      elsif(handle.at("@["))
        consumeGenerics(handle)
      else
        handle.remove()
        handle.insert("this.")
        handle.increment()
      end
    # Step over things in strings (" ") and process multiline strings
    elsif(handle.match("\""))
      consumeStrings(handle)
    # Correct access
    elsif(handle.safeMatch("public") || handle.safeMatch("private"))
      hasVisibility = true
      handle.increment()
    # Change require to classic imports
    elsif(handle.safeMatch("import"))
      handle.next("\n")
      handle.insert(";")
      handle.increment()
    # Empty operator (null)
    elsif(handle.safeMatch("void"))
      handle.remove()
      handle.insert("(function(){})()")
      handle.increment()
    # Structures and arrays
    elsif(handle.match("{"))
      opened = opened + 1
      consumeTables(handle)
      opened = opened - 1
    elsif(handle.match("["))
      opened = opened + 1
      consumeBrackets(handle, "[", "]")
      opened = opened - 1
    # Change end to classic bracket end
    elsif(handle.safeMatch("end"))
      handle.remove()
      handle.insert("}")
      handle.increment()
      opened = opened - 1

      if(currentOpened == opened)
        currentOpened = -1
        currentExpression = ""
      end

      if(opened == -1)
        currentType = ""
      end
    # Insert begin bracket after switch
    elsif(handle.safeMatch("switch"))
      currentExpression = handle.current
      currentOpened = opened
      handle.increment()
      handle.nextToken()
      consumeBrackets(handle, "(", ")")
      handle.next("\n")
      handle.insert("{")
      handle.increment()
      opened = opened + 1
    # Replaced when with Haxe "case"
    elsif(handle.safeMatch("when"))
      handle.remove()
      handle.insert("case")
      handle.increment()
      handle.nextToken()
      consumeBrackets(handle, "(", ")")
      handle.next("\n")
      handle.insert(":")
      handle.increment()
    # Insert begin bracket after try
    elsif(handle.safeMatch("try"))
      handle.increment()
      handle.insert("{")
      handle.increment()
      opened = opened + 1
    # Insert brackets around catch
    elsif(handle.safeMatch("catch"))
      handle.insert("}")
      handle.increment()
      handle.increment("catch")
      handle.nextToken()
      consumeBrackets(handle, "(", ")")
      handle.next("\n")
      handle.insert("{")
      handle.increment()
    # Insert begin bracket after if and while
    elsif(handle.safeMatch("if"))
      handle.increment()
      handle.nextToken()
      consumeBrackets(handle, "(", ")")
      handle.next("\n")
      handle.insert("{")
      handle.increment()
      opened = opened + 1
    # Change elseif to else if and insert begin and end brackets around it
    elsif(handle.safeMatch("elsif"))
      handle.remove()
      handle.insert("}else if")
      handle.increment()
      handle.nextToken()
      consumeBrackets(handle, "(", ")")
      handle.next("\n")
      handle.insert("{")
      handle.increment()
    # Insert begin brackets after loops declaration
    elsif(handle.safeMatch("while") || handle.safeMatch("for"))
      handle.increment()
      handle.nextToken()
      consumeBrackets(handle, "(", ")")
      handle.next("\n")
      handle.insert("{")
      opened = opened + 1
      handle.increment()
    # Inser begin and end brackets around else but do not try to
    # process curlys because there will not be any
    elsif(handle.safeMatch("else"))
      if(currentExpression == "switch")
        handle.remove()
        handle.insert("default:")
      else
        handle.insert("}")
        handle.increment()
        handle.increment("else")
        handle.insert("{")
      end

      handle.increment()
    # Defines to variables and functions
    elsif(handle.safeMatch("def"))
      handle.remove("def")

      def position = handle.position

      if(opened == 0 && !script)
        if(!hasVisibility)
          handle.insert("public ")
          handle.increment()
        end

        position = handle.position
        safeNextToken(handle)

        if(handle.match("@new"))
          handle.remove()
          handle.insert("static var __new = (function(){_new(); return true;})(); static  _new")
          handle.increment()
          position = handle.position - 5
        elsif(handle.match("@"))
          handle.remove()
          handle.position = position
          handle.insert("static ")
          handle.increment()
          position = handle.position
          safeNextToken(handle)
        end
      end

      hasVisibility = false
      safeNextToken(handle)

      def implicit = true

      if(handle.safeMatch("new"))
        implicit = false
        handle.increment()
        handle.nextToken()
      end

      if(handle.match("@"))
        consumeGenerics(handle)
        handle.nextToken()
      end

      if(handle.match("("))
        handle.position = position
        handle.insert("function")
        consumeBrackets(handle, "(", ")")

        while(safeNextToken(handle))
          if(handle.match("do"))
            handle.remove()

            if(implicit)
              handle.insert("return")
            end

            break
          elsif(handle.matchOne(["\n", "\#", ";"]))
            if(handle.match(";"))
              handle.remove()
            end

            if(implicit)
              handle.insert(" return{")
            else
              handle.insert("{")
            end

            handle.increment()
            opened = opened + 1
            break
          else
            process(handle)
          end
        end
      else
        handle.position = position
        handle.insert("var")
        handle.increment()
      end
    # Closures and blocks
    elsif(handle.safeMatch("do"))
      handle.remove("do")
      handle.insert("{")
      opened = opened + 1
      handle.increment()
    # [abstract] class/trait/enum
    elsif (handle.safeMatch("class") || handle.safeMatch("trait") || handle.safeMatch("enum") || handle.safeMatch("interface") || handle.safeMatch("abstract"))
      currentType = handle.current

      if(currentType != "enum" && currentType != "interface")
        handle.insert("@:tink ")
        handle.increment()
      end

      if(currentType == "trait")
        handle.remove("trait")
        handle.insert("interface")
        handle.increment()
      else
        handle.increment(currentType)
      end

      def position = handle.position
      def nameSet = false

      while(safeNextToken(handle))
        if(handle.match("@"))
          if(!nameSet)
            currentName = fileName
            nameSet = true
          end

          if(handle.at("@["))
            consumeGenerics(handle)

            if(handle.match(";"))
              handle.remove(";")

              def position = handle.position
              handle.nextToken()

              if(handle.match("\n"))
                handle.insert("{")
                handle.increment()
                opened += 1
                break
              else
                handle.position = position
              end
            end
          else
            handle.remove()
            handle.insert(currentName)
          end
        elsif(handle.match("<"))
          if(!nameSet)
            currentName = handle.content.substr(position, handle.position - position)
            nameSet = true
          end

          handle.remove()
          handle.insert("extends")
        elsif(handle.match("::"))
          if(!nameSet)
            currentName = handle.content.substr(position, handle.position - position)
            nameSet = true
          end

          handle.remove()
          handle.insert("implements")
        elsif(handle.match("\n"))
          if(!nameSet)
            currentName = handle.content.substr(position, handle.position - position)
            nameSet = true
          end

          handle.insert("{")
          handle.increment()
          opened += 1
          break
        end

        handle.increment()
      end
    # Process comments and newlines. Also, insert semicolons when needed
    elsif(handle.match("\n") || handle.match("\#"))
      consumeEndOfLine(handle, ";")
    # Word operators
    elsif(handle.safeMatch("is"))
      handle.remove()
      handle.insert("==")
      handle.increment()
    elsif(handle.safeMatch("isnt"))
      handle.remove()
      handle.insert("!=")
      handle.increment()
    elsif(handle.safeMatch("and"))
      handle.remove()
      handle.insert("&&")
      handle.increment()
    elsif(handle.safeMatch("or"))
      handle.remove()
      handle.insert("||")
      handle.increment()
    elsif(handle.safeMatch("not"))
      handle.remove()
      handle.insert("!")
      handle.increment()
    # Skip this token
    else
      handle.increment()
    end

    return handle
  end

  private def safeNextToken(handle : StringHandle) : Bool
    handle.nextToken()

    if(safeCheck(handle, "def") && safeCheck(handle, "if") && safeCheck(handle, "elsif") && safeCheck(handle, "end")  &&
        safeCheck(handle, "while") && safeCheck(handle, "for") && safeCheck(handle, "import") &&
        safeCheck(handle, "do") && safeCheck(handle, "else") && safeCheck(handle, "try") && safeCheck(handle, "catch") &&
        safeCheck(handle, "private") && safeCheck(handle, "public") && safeCheck(handle, "void") && safeCheck(handle, "switch") &&
        safeCheck(handle, "when") && safeCheck(handle, "is") && safeCheck(handle, "isnt") && safeCheck(handle, "and") &&
        safeCheck(handle, "or") && safeCheck(handle, "not"))
      return true
    else
      handle.increment()
      return safeNextToken(handle)
    end
  end

  private def safeCheck(handle : StringHandle, content : String) : Bool
    if(handle.match(content))
      return handle.safeMatch(content)
    end

    return true
  end

  private def consumeCondition(handle : StringHandle, condition : String)
    handle.increment()
    handle.insert("(")
    handle.increment()

    def curLevel = opened

    while(handle.nextToken())
      if(curLevel == opened && (handle.match("\n") || handle.match("\#")))
        if(consumeEndOfLine(handle, "){"))
          break
        end
      else
        process(handle)
      end
    end
  end

  private def consumeBrackets(handle : StringHandle, startSymbol : String, endSymbol : String, startReplace : String = null, endReplace : String = null, doProcess : Bool = true)
    def count = 0
    def startPosition = handle.position

    while(handle.nextToken())
      if(handle.match(startSymbol))
        if(count == 0 && startReplace != null)
          handle.remove()
          handle.insert(startReplace)
          handle.increment()
        else
          handle.increment()
        end

        count = count + 1
      elsif(handle.match(endSymbol))
        count = count - 1

        if(count == 0 && endReplace != null)
          handle.remove()
          handle.insert(endReplace)
          handle.increment()
        else
          handle.increment()
        end
      else
        if(doProcess)
          process(handle)
        else
          handle.increment()
        end
      end

      if(count == 0)
        break
      end
    end
  end

  private def consumeComments(handle : StringHandle)
    def comment = ""
    def position = handle.position

    while(handle.nextToken())
      if(handle.match("\#"))
        comment += "\#"
        handle.increment()
      else
        handle.increment()
        break
      end
    end

    handle.position = position
    handle.current = "\#"

    if(comment.length > 2)
      handle.remove(comment)
      handle.insert("/** ")
      handle.increment()

      while(handle.nextToken())
        if(handle.at(comment))
          handle.remove(comment)
          handle.insert(" **/")
          handle.increment()
          break
        elsif(handle.match("\#"))
          position = handle.position
          handle.prevToken()

          if(handle.match("\n") && onlyWhitespace(handle.content, position + 1, handle.position - 1))
            handle.position = position
            handle.remove("\#")
            handle.insert("*")
          else
            handle.position = position
          end

          handle.increment()
        else
          handle.increment()
        end
      end
    else
      if(handle.at("\#elsif"))
        handle.remove("\#elsif")
        handle.insert("\#elseif")
      elsif(!handle.at("\#if") && !handle.at("\#else") && !handle.at("\#end"))
        handle.remove(comment)
        handle.insert("//")
      end

      handle.next("\n")
      handle.increment()
    end

    return handle
  end

  private def consumeStrings(handle : StringHandle)
    def multiline = false

    if(handle.at("\"\"\""))
      handle.remove("\"\"\"")
      handle.insert("'")
      multiline = true
    else
      handle.remove("\"")
      handle.insert("'")
    end

    handle.increment()

    while(handle.nextToken())
      if(handle.match("\#"))
        if(isNotEscaped(handle))
          handle.remove()
          handle.insert("$")
        else
          handle.position -= 1
          handle.remove("\\")
        end

        handle.increment()
      elsif(handle.match("$"))
        handle.insert("$")
        handle.increment()
        handle.increment()
      elsif(handle.match("'"))
        handle.insert("\\")
        handle.increment()
        handle.increment("'")
      elsif(handle.match("\""))
        if(isNotEscaped(handle))
          if(multiline)
            if(handle.at("\"\"\""))
              handle.remove("\"\"\"")
              handle.insert("'")
            else
              handle.insert("\\")
              handle.increment()
              handle.increment("\"")
            end
          else
            handle.remove("\"")
            handle.insert("'")
          end

          break
        else
          handle.position -= 1
          handle.remove("\\")
          handle.increment()
        end
      else
        handle.increment()
      end
    end

    handle.increment()
  end

  private def consumeGenerics(handle : StringHandle)
    handle.remove()
    consumeBrackets(handle, "[", "]", "<", ">")
    def current = handle.current
    def position = handle.position
    handle.nextToken()

    if(handle.match("\n"))
      handle.insert(";")
    else
      handle.position = position
      handle.current = current
      handle.increment()
    end
  end

  private def isNotEscaped(handle : StringHandle) : Bool
    return (handle.content.charAt(handle.position -1) != "\\" ||
           (handle.content.charAt(handle.position -1) == "\\" && handle.content.charAt(handle.position -2) == "\\"))
  end

  private def consumeEndOfLine(handle : StringHandle, toInsert : String) : Bool
    def pos = handle.position
    def insert = true
    def isComment = handle.match("\#")

    handle.prevToken()

    if((handle.matchOne(["=", ";", "+", "-", "*", ".", "/", "," , "|", "&", "{", "(", "[", "^", "%", "~", "\n", "}", "?", ":", "<", ">"]) ||
      handle.safeMatchOne(["is", "isnt", "and", "or", "not"])) && onlyWhitespace(handle.content, handle.position + 1, pos))
      if(handle.match("-") || handle.match("+"))
        if(handle.content.charAt(handle.position - 1) != handle.current)
          insert = false
        end
      else
        insert = false
      end
    end

    handle.position = pos

    if(!isComment)
      handle.increment("\n")
      handle.nextToken()

      if((handle.matchOne(["?", ":", "=", "+", "-", "*", ".", "/", "," , "|", "&", ")", "]", "^", "%", "~", ">", "<"]) ||
        handle.safeMatchOne(["is", "isnt", "and", "or", "not"])) && onlyWhitespace(handle.content, pos + 1, handle.position - 1))
        insert = false
      end

      handle.prev("\n")
    end

    if(insert && !handle.atStart())
      handle.insert(toInsert)
      handle.increment()
    end

    if(isComment)
      consumeComments(handle)
    else
      handle.increment()
    end

    return insert && !handle.atStart()
  end

  private def consumeTables(handle : StringHandle)
    def pos = handle.position
    def arrayAccess : Bool = true
    handle.increment()

    while(safeNextToken(handle))
      if(handle.match("[") and onlyWhitespace(handle.content, pos + 1, handle.position - 1))
        def curr = opened

        while(handle.nextToken())
          if(opened is curr)
            if(handle.match("["))
              consumeBrackets(handle, "[", "]", "", "")
            elsif(handle.match("="))
              handle.remove()
              handle.insert("=>")
              handle.increment()
            elsif(handle.match("}"))
              break
            else
              handle.increment()
            end
          else
            handle.increment()
          end
        end

        break
      elsif(handle.match(":"))
        arrayAccess = false
        break
      elsif(handle.match("\n") or handle.match("\"") or handle.match("\#"))
        process(handle)
      else
        break
      end
    end

    if(arrayAccess)
      handle.position = pos
      consumeBrackets(handle, "{", "}", "[", "]")
    end
  end

  private def nextNoWhitespace(handle : StringHandle)
    while(handle.nextToken())
      if(handle.match("\n"))
        handle.increment()
      elsif(handle.match("#"))
        consumeComments(handle)
      else
        break
      end
    end
  end

  private def onlyWhitespace(content : String, from : Int, to : Int)
    ~/^\s*$/.match(content.substr(from, to - from))
  end
end
